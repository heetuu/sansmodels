#!/usr/bin/env python
"""
	This software was developed by the University of Tennessee as part of the
	Distributed Data Analysis of Neutron Scattering Experiments (DANSE)
	project funded by the US National Science Foundation.

	If you use DANSE applications to do scientific research that leads to
	publication, we ask that you acknowledge the use of the software with the
	following sentence:

	"This work benefited from DANSE software developed under NSF award DMR-0520547."

	copyright 2008, University of Tennessee
"""

""" Provide functionality for a C extension model

	WARNING: THIS FILE WAS GENERATED BY WRAPPERGENERATOR.PY
 	         DO NOT MODIFY THIS FILE, MODIFY ..\c_extensions\prolate.h
 	         AND RE-RUN THE GENERATOR SCRIPT

"""

from sans.models.BaseComponent import BaseComponent
from sans_extension.c_models import CProlateModel
import copy    
    
class ProlateModel(CProlateModel, BaseComponent):
    """ Class that evaluates a ProlateModel model. 
    	This file was auto-generated from ..\c_extensions\prolate.h.
    	Refer to that file and the structure it contains
    	for details of the model.
    	List of default parameters:
         scale           = 1.0 
         major_core      = 100.0 [A]
         minor_core      = 50.0 [A]
         major_shell     = 110.0 [A]
         minor_shell     = 60.0 [A]
         contrast        = 1e-006 [1/A^(2)]
         sld_solvent     = 6.3e-006 [1/A^(2)]
         background      = 0.001 [1/cm]

    """
        
    def __init__(self):
        """ Initialization """
        
        # Initialize BaseComponent first, then sphere
        BaseComponent.__init__(self)
        CProlateModel.__init__(self)
        
        ## Name of the model
        self.name = "ProlateModel"
        ## Model description
        self.description ="""[ProlateCoreShellModel] Calculates the form factor for a prolate
		ellipsoid particle with a core_shell structure.
		The form factor is averaged over all possible
		orientations of the ellipsoid such that P(q)
		= scale*<f^2>/Vol + bkg, where f is the
		single particle scattering amplitude.
		[Parameters]:
		major_core = radius of major_core,
		minor_core = radius of minor_core,
		major_shell = radius of major_shell,
		minor_shell = radius of minor_shell,
		contrast = SLD_core - SLD_shell
		sld_solvent = SLD_solvent
		background = Incoherent bkg
		scale = scale
		Note:It is the users' responsibility to ensure
		that shell radii are larger than core radii."""
       
		## Parameter details [units, min, max]
        self.details = {}
        self.details['scale'] = ['', None, None]
        self.details['major_core'] = ['[A]', None, None]
        self.details['minor_core'] = ['[A]', None, None]
        self.details['major_shell'] = ['[A]', None, None]
        self.details['minor_shell'] = ['[A]', None, None]
        self.details['contrast'] = ['[1/A^(2)]', None, None]
        self.details['sld_solvent'] = ['[1/A^(2)]', None, None]
        self.details['background'] = ['[1/cm]', None, None]

		## fittable parameters
        self.fixed=['major_core.width', 'minor_core.width', 'major_shell.width', 'minor_shell.width']
        
        ## parameters with orientation
        self.orientation_params =[]
   
    def clone(self):
        """ Return a identical copy of self """
        return self._clone(ProlateModel())   
   
    def run(self, x = 0.0):
        """ Evaluate the model
            @param x: input q, or [q,phi]
            @return: scattering function P(q)
        """
        
        return CProlateModel.run(self, x)
   
    def runXY(self, x = 0.0):
        """ Evaluate the model in cartesian coordinates
            @param x: input q, or [qx, qy]
            @return: scattering function P(q)
        """
        
        return CProlateModel.runXY(self, x)
        
    def evalDistribition(self, x = []):
        """ Evaluate the model in cartesian coordinates
            @param x: input q[], or [qx[], qy[]]
            @return: scattering function P(q[])
        """
        return CProlateModel.evalDistribition(self, x)
        
    def calculate_ER(self):
        """ Calculate the effective radius for P(q)*S(q)
            @return: the value of the effective radius
        """       
        return CProlateModel.calculate_ER(self)
        
    def set_dispersion(self, parameter, dispersion):
        """
            Set the dispersion object for a model parameter
            @param parameter: name of the parameter [string]
            @dispersion: dispersion object of type DispersionModel
        """
        return CProlateModel.set_dispersion(self, parameter, dispersion.cdisp)
        
   
# End of file
