/** CStackedDisksModel
 *
 * C extension 
 *
 * WARNING: THIS FILE WAS GENERATED BY WRAPPERGENERATOR.PY
 *          DO NOT MODIFY THIS FILE, MODIFY stacked_disks.h
 *          AND RE-RUN THE GENERATOR SCRIPT
 *
 * @author   M.Doucet / UTK
 */
 
#include <Python.h>
#include "structmember.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include "stacked_disks.h"

/// Error object for raised exceptions
static PyObject * CStackedDisksModelError = NULL;


// Class definition
typedef struct {
    PyObject_HEAD
    /// Parameters
    PyObject * params;
    /// Log for unit testing
    PyObject * log;
    /// Model parameters
	StackedDisksParameters model_pars;
} CStackedDisksModel;


static void
CStackedDisksModel_dealloc(CStackedDisksModel* self)
{
    self->ob_type->tp_free((PyObject*)self);
    

}

static PyObject *
CStackedDisksModel_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    CStackedDisksModel *self;
    
    self = (CStackedDisksModel *)type->tp_alloc(type, 0);
   
    return (PyObject *)self;
}

static int
CStackedDisksModel_init(CStackedDisksModel *self, PyObject *args, PyObject *kwds)
{
    if (self != NULL) {
    	
    	// Create parameters
        self->params = PyDict_New();
        
        // Initialize parameter dictionary
        PyDict_SetItemString(self->params,"core_sld",Py_BuildValue("d",0.000004));
        PyDict_SetItemString(self->params,"core_thick",Py_BuildValue("d",10.000000));
        PyDict_SetItemString(self->params,"layer_thick",Py_BuildValue("d",15.000000));
        PyDict_SetItemString(self->params,"axis_theta",Py_BuildValue("d",0.000000));
        PyDict_SetItemString(self->params,"layer_sld",Py_BuildValue("d",-0.000000));
        PyDict_SetItemString(self->params,"axis_phi",Py_BuildValue("d",0.000000));
        PyDict_SetItemString(self->params,"solvent_sld",Py_BuildValue("d",0.000005));
        PyDict_SetItemString(self->params,"scale",Py_BuildValue("d",0.010000));
        PyDict_SetItemString(self->params,"radius",Py_BuildValue("d",3000.000000));
        PyDict_SetItemString(self->params,"background",Py_BuildValue("d",0.001000));
        PyDict_SetItemString(self->params,"sigma_d",Py_BuildValue("d",0.000000));
        PyDict_SetItemString(self->params,"n_stacking",Py_BuildValue("d",1.000000));

         
        // Create empty log
        self->log = PyDict_New();
        
        

    }
    return 0;
}

static PyMemberDef CStackedDisksModel_members[] = {
    {"params", T_OBJECT, offsetof(CStackedDisksModel, params), 0,
     "Parameters"},
    {"log", T_OBJECT, offsetof(CStackedDisksModel, log), 0,
     "Log"},
    {NULL}  /* Sentinel */
};

/** Read double from PyObject
    @param p PyObject
    @return double
*/
double CStackedDisksModel_readDouble(PyObject *p) {
    if (PyFloat_Check(p)==1) {
        return (double)(((PyFloatObject *)(p))->ob_fval);
    } else if (PyInt_Check(p)==1) {
        return (double)(((PyIntObject *)(p))->ob_ival);
    } else if (PyLong_Check(p)==1) {
        return (double)PyLong_AsLong(p);
    } else {
        return 0.0;
    }
}


/**
 * Function to call to evaluate model
 * @param args: input q or [q,phi]
 * @return: function value
 */
static PyObject * run(CStackedDisksModel *self, PyObject *args) {
	double q_value, phi_value;
	PyObject* pars;
	int npars;
	
	// Get parameters
	
	// Reader parameter dictionary
    self->model_pars.core_sld = PyFloat_AsDouble( PyDict_GetItemString(self->params, "core_sld") );
    self->model_pars.core_thick = PyFloat_AsDouble( PyDict_GetItemString(self->params, "core_thick") );
    self->model_pars.layer_thick = PyFloat_AsDouble( PyDict_GetItemString(self->params, "layer_thick") );
    self->model_pars.axis_theta = PyFloat_AsDouble( PyDict_GetItemString(self->params, "axis_theta") );
    self->model_pars.layer_sld = PyFloat_AsDouble( PyDict_GetItemString(self->params, "layer_sld") );
    self->model_pars.axis_phi = PyFloat_AsDouble( PyDict_GetItemString(self->params, "axis_phi") );
    self->model_pars.solvent_sld = PyFloat_AsDouble( PyDict_GetItemString(self->params, "solvent_sld") );
    self->model_pars.scale = PyFloat_AsDouble( PyDict_GetItemString(self->params, "scale") );
    self->model_pars.radius = PyFloat_AsDouble( PyDict_GetItemString(self->params, "radius") );
    self->model_pars.background = PyFloat_AsDouble( PyDict_GetItemString(self->params, "background") );
    self->model_pars.sigma_d = PyFloat_AsDouble( PyDict_GetItemString(self->params, "sigma_d") );
    self->model_pars.n_stacking = PyFloat_AsDouble( PyDict_GetItemString(self->params, "n_stacking") );

	
	// Get input and determine whether we have to supply a 1D or 2D return value.
	if ( !PyArg_ParseTuple(args,"O",&pars) ) {
	    PyErr_SetString(CStackedDisksModelError, 
	    	"CStackedDisksModel.run expects a q value.");
		return NULL;
	}
	  
	// Check params
	if( PyList_Check(pars)==1) {
		
		// Length of list should be 2 for I(q,phi)
	    npars = PyList_GET_SIZE(pars); 
	    if(npars!=2) {
	    	PyErr_SetString(CStackedDisksModelError, 
	    		"CStackedDisksModel.run expects a double or a list of dimension 2.");
	    	return NULL;
	    }
	    // We have a vector q, get the q and phi values at which
	    // to evaluate I(q,phi)
	    q_value = CStackedDisksModel_readDouble(PyList_GET_ITEM(pars,0));
	    phi_value = CStackedDisksModel_readDouble(PyList_GET_ITEM(pars,1));
	    // Skip zero
	    if (q_value==0) {
	    	return Py_BuildValue("d",0.0);
	    }
		return Py_BuildValue("d",stacked_disks_analytical_2D(&(self->model_pars),q_value,phi_value));

	} else {

		// We have a scalar q, we will evaluate I(q)
		q_value = CStackedDisksModel_readDouble(pars);		
		
		return Py_BuildValue("d",stacked_disks_analytical_1D(&(self->model_pars),q_value));
	}	
}

/**
 * Function to call to evaluate model in cartesian coordinates
 * @param args: input q or [qx, qy]]
 * @return: function value
 */
static PyObject * runXY(CStackedDisksModel *self, PyObject *args) {
	double qx_value, qy_value;
	PyObject* pars;
	int npars;
	
	// Get parameters
	
	// Reader parameter dictionary
    self->model_pars.core_sld = PyFloat_AsDouble( PyDict_GetItemString(self->params, "core_sld") );
    self->model_pars.core_thick = PyFloat_AsDouble( PyDict_GetItemString(self->params, "core_thick") );
    self->model_pars.layer_thick = PyFloat_AsDouble( PyDict_GetItemString(self->params, "layer_thick") );
    self->model_pars.axis_theta = PyFloat_AsDouble( PyDict_GetItemString(self->params, "axis_theta") );
    self->model_pars.layer_sld = PyFloat_AsDouble( PyDict_GetItemString(self->params, "layer_sld") );
    self->model_pars.axis_phi = PyFloat_AsDouble( PyDict_GetItemString(self->params, "axis_phi") );
    self->model_pars.solvent_sld = PyFloat_AsDouble( PyDict_GetItemString(self->params, "solvent_sld") );
    self->model_pars.scale = PyFloat_AsDouble( PyDict_GetItemString(self->params, "scale") );
    self->model_pars.radius = PyFloat_AsDouble( PyDict_GetItemString(self->params, "radius") );
    self->model_pars.background = PyFloat_AsDouble( PyDict_GetItemString(self->params, "background") );
    self->model_pars.sigma_d = PyFloat_AsDouble( PyDict_GetItemString(self->params, "sigma_d") );
    self->model_pars.n_stacking = PyFloat_AsDouble( PyDict_GetItemString(self->params, "n_stacking") );

	
	// Get input and determine whether we have to supply a 1D or 2D return value.
	if ( !PyArg_ParseTuple(args,"O",&pars) ) {
	    PyErr_SetString(CStackedDisksModelError, 
	    	"CStackedDisksModel.run expects a q value.");
		return NULL;
	}
	  
	// Check params
	if( PyList_Check(pars)==1) {
		
		// Length of list should be 2 for I(qx, qy))
	    npars = PyList_GET_SIZE(pars); 
	    if(npars!=2) {
	    	PyErr_SetString(CStackedDisksModelError, 
	    		"CStackedDisksModel.run expects a double or a list of dimension 2.");
	    	return NULL;
	    }
	    // We have a vector q, get the qx and qy values at which
	    // to evaluate I(qx,qy)
	    qx_value = CStackedDisksModel_readDouble(PyList_GET_ITEM(pars,0));
	    qy_value = CStackedDisksModel_readDouble(PyList_GET_ITEM(pars,1));
		return Py_BuildValue("d",stacked_disks_analytical_2DXY(&(self->model_pars),qx_value,qy_value));

	} else {

		// We have a scalar q, we will evaluate I(q)
		qx_value = CStackedDisksModel_readDouble(pars);		
		
		return Py_BuildValue("d",stacked_disks_analytical_1D(&(self->model_pars),qx_value));
	}	
}

static PyObject * reset(CStackedDisksModel *self, PyObject *args) {
    

    return Py_BuildValue("d",0.0);
}


static PyMethodDef CStackedDisksModel_methods[] = {
    {"run",      (PyCFunction)run     , METH_VARARGS,
      "Evaluate the model at a given Q or Q, phi"},
    {"runXY",      (PyCFunction)runXY     , METH_VARARGS,
      "Evaluate the model at a given Q or Qx, Qy"},
    {"reset",    (PyCFunction)reset   , METH_VARARGS,
      "Reset pair correlation"},
    //{"numerical_1D",      (PyCFunction)numerical_1D     , METH_VARARGS,
    //  "Evaluate the 1D model at a given Q"},
   {NULL}
};

static PyTypeObject CStackedDisksModelType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "CStackedDisksModel",             /*tp_name*/
    sizeof(CStackedDisksModel),             /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)CStackedDisksModel_dealloc, /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    0,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
    "CStackedDisksModel objects",           /* tp_doc */
    0,		               /* tp_traverse */
    0,		               /* tp_clear */
    0,		               /* tp_richcompare */
    0,		               /* tp_weaklistoffset */
    0,		               /* tp_iter */
    0,		               /* tp_iternext */
    CStackedDisksModel_methods,             /* tp_methods */
    CStackedDisksModel_members,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    (initproc)CStackedDisksModel_init,      /* tp_init */
    0,                         /* tp_alloc */
    CStackedDisksModel_new,                 /* tp_new */
};


static PyMethodDef module_methods[] = {
    {NULL} 
};

/**
 * Function used to add the model class to a module
 * @param module: module to add the class to
 */ 
void addCStackedDisksModel(PyObject *module) {
	PyObject *d;
	
    if (PyType_Ready(&CStackedDisksModelType) < 0)
        return;

    Py_INCREF(&CStackedDisksModelType);
    PyModule_AddObject(module, "CStackedDisksModel", (PyObject *)&CStackedDisksModelType);
    
    d = PyModule_GetDict(module);
    CStackedDisksModelError = PyErr_NewException("CStackedDisksModel.error", NULL, NULL);
    PyDict_SetItemString(d, "CStackedDisksModelError", CStackedDisksModelError);
}

